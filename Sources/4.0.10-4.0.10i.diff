Index: CHANGELOG
===================================================================
RCS file: /home/cvs/atlantis/CHANGELOG,v
retrieving revision 1.106
diff -u -r1.106 CHANGELOG
--- CHANGELOG	19 Jul 2002 21:09:35 -0000	1.106
+++ CHANGELOG	29 Jan 2003 06:23:36 -0000
@@ -460,12 +460,12 @@
       the Lacandon spells fully implementable.
    -- The CLEAR_SKIES castable at range stuff is now doable by setting the
       rangeIndex on S_CLEAR_SKIES to RANGE_CLEAR_SKIES and then modifying
-	  the values for RANGE_CLEAR_SKIES.
+      the values for RANGE_CLEAR_SKIES.
    -- Fixed planar scaling so that all levels were scaled to what they should
       be, not always *2 for levels other than surface.
    -- Fixed a bug which caused a crash in the orders checker if you had a
       bogus form order and did NOT have either an ENDFORM of #END order in
-	  your orderset after that bogus form.
+      your orderset after that bogus form.
    -- Fixed a bug which caused a crash if you built a road in a direction
       where there was no adjacent hex.
    -- Fixed a bug in unit drowning when they left a boat.
@@ -474,10 +474,10 @@
    -- Fixed a bug in display of info about shield effects generated by items.
    -- Fixed bug in forlist during assassination which caused assassinations
       to stop if the person you assassinated was directly below you in the
-	  unit list in the object.
+      unit list in the object.
    -- Tom Alsen added code to Blitzgame allowing monsters to regenerate hits
       during combat.  I have merged this code into the main base under a
-	  configuration option.
+      configuration option.
    -- Patch for multiple types of taxing behaviour controlling who is
       allowed to tax.  Patch submitted by Stephen Baillie.
    -- Fixed a bug in BUY/SELL where two buys or sells of the same item would
@@ -503,8 +503,8 @@
    -- Cleaned up a small section of rules for clarity.
    -- Fixed up a bug with two sell orders for the same item which did
       insufficient checking that you could sell both quantities.  This
-	  bug existed for a while but never showed up because of the bug
-	  with multiple sells of the same item which I fixed a few weeks ago.
+      bug existed for a while but never showed up because of the bug
+      with multiple sells of the same item which I fixed a few weeks ago.
    -- Changed MOVE and SAIL so that if the unit runs out of movement
       points, the remaining moves are added to the front of the TURN
       queue.  This allows caravans using @TURN to work properly despite
@@ -532,7 +532,7 @@
       Made food buyable in all town markets.
    -- Made it so that shield items didn't need to be PREPARED in a game with
       USE_PREPARE_COMMAND set and verified that non-prepared items got
-	  returned.
+      returned.
    -- Fixed display of hits/regen to show unit number and creature in unit
       which took the damage.
    -- Fixed bug in magic studying in protected buildings under LIMITED_MAGES
@@ -546,3 +546,108 @@
    -- Fixed a bug in teleport and such which allowed entry into and out of
       the Abyss (and viewing it via farsight and such).  Bad JT, no biscuit.
       Thanks AZ for pointing it out.
+
+Changes from 4.0.10 -> 4.0.10a
+--------------------------------------------------
+   -- Fixed bug in conquest map generation caused by terrain change patch
+   -- Fixed potential namespace collision on 'fill' in template.cpp
+
+Changes from 4.0.10a -> 4.0.10b
+--------------------------------------------------
+   -- Fixed bug with extremely large worlds and more than 10000 units
+   -- Fixed bug with small worlds/levels where a town was less than 9
+      hexes from *both* poles AND LESS_ARTIC_TOWNS was enabled.  This
+      caused very large negative/positive numbers for wages and such.
+   -- Fixed a bug in random number generation when getrandom was called
+      on a negative number (found while fixing the one above)
+   -- Fixed a potential crash when evicting someone who had already
+      left the building.
+   -- Fixed a couple of typos in the generated rules.
+
+Changes from 4.0.10b -> 4.0.10c
+--------------------------------------------------
+   -- Fixed probability of town generation bug from Jan's patch.
+   -- Fixed bug in movement costs when WEATHER_EXISTS was 0.
+   -- Added 'Spoils: none' line to indecisive battles to make ACB happier
+   -- Fixed segfault in skill starvation code.
+
+Changes from 4.0.10c -> 4.0.10d
+--------------------------------------------------
+   -- Fixed a coredump when a region affecting spell was used on a z level
+      that was out of range.  Bad range-check.. bad!
+   -- Fixed misleading damage messages on monsters.
+   -- Fixed a bug where gluttony became a sin (under skill starvation).
+   -- Fixed rounding error in pillaging 
+
+Changes from 4.0.10d -> 4.0.10e
+--------------------------------------------------
+   -- Fixed missing parenthesis in calculating rename cost of cities.
+   -- Fixed setup error in city markets (wasn't obeying the directive
+      CITY_MARKET_NORMAL_AMT in one case)
+   -- Fixed bug in AString::value() where an excessively large number
+      could be used to overflow an integer into a negative and thus
+      cause some very wierd effects (such as creating items out of
+      nothing)
+   -- Fixed a bug where a faction could get more apprentices than they
+      should be allowed.
+   -- Fixed bug in tax being a month-long order and issuing the 'tax'
+      command giving an error about work overwriting and then the unit
+      working instead of taxing.
+   -- Fixed bug where autotax didn't work if DEFAULT_WORK_ORDER was
+      disabled and the unit was submitted as part of an orderset but had
+      blank orders (only when TAX_PILLAGE_MONTHLONG was set).
+
+Changes from 4.0.10e -> 4.0.10f
+--------------------------------------------------
+   -- Fixed bug in practice code where non-leader units would keep trying
+      to practice and generate errors even after they were at max level.
+
+Changes from 4.0.10f -> 4.0.10g
+--------------------------------------------------
+   -- Changed USE_PREPARE slightly.  There is now a 'strict' and a 'normal'
+      setting for USE_PREPARE.  Under strict, the READY command MUST be
+      used or the unit will not use any battle items.  Under normal, the
+      unit will fall back on the battle items list.
+
+Changes from 4.0.10g -> 4.0.10h
+--------------------------------------------------
+   -- Fixed a bug which caused the first mage casting Earth Lore in a
+      region to recieve 2*level less silver than he should.
+   -- Fixed a bug where an army where all casualties were healed were
+      prevented from further moves or attacks.  Full healing should mean
+      no penalties.
+   -- Fixed a bug in output of rules when dealing with skill-based
+      maintainence.
+   -- Fixed a bug dealing with the cost of non-skilled units versus skilled
+      units when in a maintenance mode which requires skill based upkeep.
+      Units will now pay the maximum of the skill based upkeep or the normal
+      upkeep.  This means that GM's should probably *lower* the normal upkeep
+      to something more reasonable than 10/20 if they are using the skill
+      based upkeep unless they JUST want to penalize higher skilled leaders.
+
+Changes from 4.0.10h -> 4.0.10i
+--------------------------------------------------
+   -- Fix bug where completed buildings weren't adding protection in battle.
+   -- Made a small change to battle output requested by the author of
+      atlaclient.
+   -- Fixed a bug in building where using an enter order on the same turn as
+      a build caused you to be in the wrong building to build and thus not
+      actually build.
+   -- Fixed a bug in construct gate which made it successful 100% of the time
+      at level 1, instead of 20% at level 1 up to 100% at level 5.
+   -- made all town pop functions use CITY_POP instead of local constants
+   -- fixed a bug where the 'rural' hex population was taken into account
+      when markets were set up, but not when market items were considered
+      for their activity and effect on town growth.
+   -- Markets: all except food set their amount to zero below the minimum
+      pop, and the minimum amount (1/6th of total amount for trade items and
+      normal items on demand) is used as soon as an item becomes available.
+   -- the minimum amount of economically relevant items is set to at least
+      1/6th the total (this affects games in progress).
+   -- added 'staggered' markets: for more than one items of a type, an
+      increasing offset is added to the minimum population of that item's
+      market (so item 1 will appear at 1000+, item 2 at 1300+, item 3 at
+      1600+ for instance).
+   -- Fixed bug in @ENDTURN.
+   -- Fixed bug with skill-based maintanence costs.
+   -- Cleaned up includes to compile without warnings under gcc 3.2
Index: aregion.cpp
===================================================================
RCS file: /home/cvs/atlantis/aregion.cpp,v
retrieving revision 1.50
diff -u -r1.50 aregion.cpp
--- aregion.cpp	19 Jul 2002 21:09:35 -0000	1.50
+++ aregion.cpp	21 Jan 2003 01:38:26 -0000
@@ -119,8 +119,8 @@
 
 int TownInfo::TownType()
 {
-	if (pop < 1000) return TOWN_VILLAGE;
-	if (pop < 2000) return TOWN_TOWN;
+	if (pop < Globals->CITY_POP/4) return TOWN_VILLAGE;
+	if (pop < Globals->CITY_POP/2) return TOWN_TOWN;
 	return TOWN_CITY;
 }
 
@@ -278,7 +278,7 @@
 		int adjacent = 0;
 		int prob = Globals->TOWN_PROBABILITY;
 		if (prob < 1) prob = 100;
-		int townch = (int) 800 * (100 / prob);
+		int townch = (int) 80000 / prob;
 		if (Globals->TOWNS_NOT_ADJACENT) {
 			for (int d = 0; d < NDIRS; d++) {
 				ARegion *newregion = neighbors[d];
@@ -374,12 +374,19 @@
 void ARegion::SetupCityMarket()
 {
 	int numtrade = 0;
+	int normalbuy = 0;
+	int normalsell = 0;
+	int advanced = 0;
+	int magic = 0;
+	int citymax = Globals->CITY_POP;
 	int i;
 	for (i=0; i<NITEMS; i++) {
 		if(ItemDefs[i].flags & ItemType::DISABLED) continue;
 		if(ItemDefs[i].flags & ItemType::NOMARKET) continue;
 
 		int j;
+		int cap;
+		int offset = 0;
 		if(ItemDefs[ i ].type & IT_NORMAL) {
 			if (i==I_SILVER) continue;
 			if (i==I_GRAIN || i==I_LIVESTOCK || i==I_FISH) {
@@ -396,8 +403,10 @@
 					price = ItemDefs[ i ].baseprice;
 				}
 
+				cap = (citymax * 3/4) - 1000;
+				if(cap < 0) cap = citymax/2;
 				Market * m = new Market (M_SELL, i, price, amt, population,
-						population+2000, amt, amt*2);
+						population+cap, amt, amt*2);
 				markets.Add(m);
 			} else if (i == I_FOOD) {
 				int amt = Globals->CITY_MARKET_NORMAL_AMT;
@@ -411,8 +420,10 @@
 					price = ItemDefs[ i ].baseprice;
 				}
 
-				Market * m = new Market (M_BUY, i, price, amt, population+500,
-						population+3000, amt, amt*5);
+				cap = (citymax / 8);
+				if(cap < citymax) cap = (citymax * 3/4);
+				Market * m = new Market (M_BUY, i, price, amt, population+cap,
+						population+6*cap, amt, amt*5);
 				markets.Add(m);
 			} else {
 				if (ItemDefs[i].pInput[0].item == -1) {
@@ -442,10 +453,13 @@
 							} else {
 								price = ItemDefs[ i ].baseprice;
 							}
-
+							
+							cap = (citymax/4);
+							offset = (normalbuy++ * citymax * 3 / 40);
+							// raw goods have a basic offset of 0							
 							Market * m = new Market (M_BUY, i, price, 0,
-									1000+population, 4000+population, 0,
-									50 + getrandom(50));
+									population+cap+offset, population+citymax,
+									0, amt);
 							markets.Add(m);
 						}
 					} else {
@@ -464,9 +478,11 @@
 							} else {
 								price = ItemDefs[ i ].baseprice;
 							}
-
-							Market * m = new Market (M_SELL, i, price, 0,
-									1000+population, 4000+population, 0, amt);
+							
+							cap = (citymax/4);
+							offset = - (citymax/20) + (normalsell++ * citymax * 3/40);
+							Market * m = new Market (M_SELL, i, price, amt/6,
+									population+cap+offset, population+citymax, 0, amt);
 							markets.Add(m);
 						}
 					}
@@ -482,8 +498,10 @@
 							price = ItemDefs[ i ].baseprice;
 						}
 
-						Market * m = new Market (M_SELL, i, price, 0,
-								1000+population, 4000+population, 0, amt);
+						cap = (citymax/4);
+						offset = - (citymax/20) + (normalsell++ * citymax * 3/40);
+						Market * m = new Market (M_SELL, i, price, amt/6,
+								population+cap+offset, population+citymax, 0, amt);
 						markets.Add(m);
 					} else {
 						if (!getrandom(6)) {
@@ -498,8 +516,13 @@
 								price = ItemDefs[ i ].baseprice;
 							}
 
+							cap = (citymax/4);
+							offset = (citymax/20) + (normalbuy++ * citymax * 3/40);
+							// finished goods have a higher offset than raw goods
 							Market * m = new Market (M_BUY, i, price, 0,
-									1000+population, 4000+population, 0, amt);
+									population+cap+offset, population+citymax+offset, 0, amt);
+							// Offset added to maxamt too to reflect lesser production capacity
+							// the more items are on sale.
 							markets.Add(m);
 						}
 					}
@@ -519,9 +542,14 @@
 					price = ItemDefs[ i ].baseprice;
 				}
 
-				Market * m = new Market (M_SELL, i, price, 0, 2000+population,
-						4000+population, 0, amt);
-				markets.Add(m);
+				cap = (citymax *3/4) - 1000;
+				if(cap < citymax/2) cap = citymax / 2;
+				offset = ((citymax / 8) * advanced++);
+				if (cap+offset < citymax) {
+					Market * m = new Market (M_SELL, i, price, amt/6, population+cap+offset,
+						population+citymax, 0, amt);
+					markets.Add(m);
+				}
 			}
 		} else if(ItemDefs[ i ].type & IT_MAGIC) {
 			j = getrandom(8);
@@ -537,8 +565,11 @@
 					price = ItemDefs[ i ].baseprice;
 				}
 
-				Market * m = new Market (M_SELL, i, price, 0, 2000+population,
-						4000+population, 0, amt);
+				cap = (citymax *3/4) - 1000;
+				if(cap < citymax/2) cap = citymax / 2;
+				offset = (citymax/20) + ((citymax/5) * (magic++ +1));
+				Market * m = new Market (M_SELL, i, price, amt/6, population+cap,
+						population+citymax, 0, amt);
 				markets.Add(m);
 			}
 		} else if(ItemDefs[ i ].type & IT_TRADE) {
@@ -551,6 +582,10 @@
 	int buy2 = getrandom(numtrade);
 	int sell1 = getrandom(numtrade);
 	int sell2 = getrandom(numtrade);
+	int tradebuy = 0;
+	int tradesell = 0;
+	int offset = 0;
+	int cap = 0;
 
 	buy1 = getrandom(numtrade);
 	while (buy1 == buy2) buy2 = getrandom(numtrade);
@@ -592,10 +627,14 @@
 				} else {
 					price = ItemDefs[ i ].baseprice;
 				}
-
-				Market * m = new Market (M_SELL, i, price, 0, 2000+population,
-						4000+population, 0, amt);
-				markets.Add(m);
+				
+				cap = (citymax/2);
+				offset = - (citymax/20) + tradesell++ * (tradesell * tradesell * citymax/40);
+				if(cap + offset < citymax) {
+					Market * m = new Market (M_SELL, i, price, amt/5, cap+population+offset,
+						citymax+population, 0, amt);
+					markets.Add(m);
+				}
 			}
 
 			if(addsell) {
@@ -613,9 +652,13 @@
 					price = ItemDefs[ i ].baseprice;
 				}
 
-				Market * m = new Market (M_BUY, i, price, 0, 2000+population,
-						4000+population, 0, amt);
-				markets.Add(m);
+				cap = (citymax/2);
+				offset = tradebuy++ * (citymax/6);
+				if(cap+offset < citymax) {
+					Market * m = new Market (M_BUY, i, price, amt/6, cap+population+offset,
+						citymax+population, 0, amt);
+					markets.Add(m);
+				}
 			}
 		}
 	}
@@ -661,18 +704,24 @@
 	town->name = new AString(AGetNameString(AGetName(1)));
 
 	if(Globals->RANDOM_ECONOMY) {
-		int popch = 2500;
+		int popch = (Globals->CITY_POP * 16/10);
 		if(Globals->LESS_ARCTIC_TOWNS) {
 			int dnorth = GetPoleDistance(D_NORTH);
 			int dsouth = GetPoleDistance(D_SOUTH);
-			if (dnorth < 9)
-				popch = popch - (9 - dnorth) * ((9 - dnorth) + 10) * 15;
-			if (dsouth < 9)
-				popch = popch - (9 - dsouth) * ((9 - dsouth) + 10) * 15;
+			int dist = dnorth;
+
+			/*
+			 * On small worlds, or the underworld levels, both distances
+			 * could be less than 9, so choose the smallest.
+			 */
+			if (dsouth < dist) dist = dsouth;
+
+			if (dist < 9)
+				popch = popch - (9 - dist) * ((9 - dist) + 10) * 15;
 		}
-		town->pop = 500+getrandom(popch);
+		town->pop = (Globals->CITY_POP/8)+getrandom(popch);
 	} else {
-		town->pop = 500;
+		town->pop = (Globals->CITY_POP/8);
 	}
 
 	town->basepop = town->pop;
@@ -814,7 +863,7 @@
 		int tot = 0;
 		forlist(&markets) {
 			Market * m = (Market *) elem;
-			if (town->pop > m->minpop) {
+			if (Population() > m->minpop) {
 				if (ItemDefs[m->item].type & IT_TRADE) {
 					if (m->type == M_BUY) {
 						amt += 5 * m->activity;
@@ -2136,7 +2185,7 @@
 
 int ARegion::MoveCost(int movetype, ARegion *fromRegion, int dir)
 {
-	int cost = -1;
+	int cost = 1;
 	if(Globals->WEATHER_EXISTS) {
 		cost = 2;
 		if (weather == W_BLIZZARD) return 10;
@@ -2454,6 +2503,9 @@
 
 ARegion *ARegionList::GetRegion(int x, int y, int z)
 {
+
+	if (z >= numLevels) return NULL;
+
 	ARegionArray *arr = pRegionArrays[ z ];
 
 	x = (x + arr->x) % arr->x;
@@ -3151,11 +3203,13 @@
 						adjname = newregion->wages;
 					}
 				}
-				if (adjtype) {
+				if (adjtype && !Globals->CONQUEST_GAME) {
 					reg->type = adjtype;
 					reg->wages = adjname;
-				} else reg->type = GetRegType(reg);
-				reg->wages = AGetName(0);
+				} else {
+					reg->type = GetRegType(reg);
+					reg->wages = AGetName(0);
+				}
 			}
 		}
 	}
Index: army.cpp
===================================================================
RCS file: /home/cvs/atlantis/army.cpp,v
retrieving revision 1.51
diff -u -r1.51 army.cpp
--- army.cpp	16 Jul 2002 23:28:41 -0000	1.51
+++ army.cpp	18 Jan 2003 19:42:32 -0000
@@ -70,6 +70,7 @@
 	dskill[ATTACK_WEATHER] = -2;
 	dskill[ATTACK_RIDING] = 0;
 	dskill[ATTACK_RANGED] = 0;
+	damage = 0;
 	hits = 1;
 	maxhits = 1;
 	amuletofi = 0;
@@ -94,7 +95,7 @@
 	if (ItemDefs[r].type & IT_MONSTER) {
 		int mon = ItemDefs[r].index;
 		if(u->type == U_WMON)
-			name = AString(MonDefs[mon].name);
+			name = AString(MonDefs[mon].name) + " in " + *(unit->name);
 		else
 			name = AString(MonDefs[mon].name) +
 				AString(" controlled by ") + *(unit->name);
@@ -111,6 +112,7 @@
 		}
 		dskill[ATTACK_RIDING] += MonDefs[mon].defense[ATTACK_RIDING];
 		dskill[ATTACK_RANGED] += MonDefs[mon].defense[ATTACK_RANGED];
+		damage = 0;
 		hits = MonDefs[mon].hits;
 		if (hits < 1) hits = 1;
 		maxhits = hits;
@@ -280,6 +282,8 @@
 		// it's the right one, or unless it is a shield which doesn't
 		// need preparing.
 		if(!Globals->USE_PREPARE_COMMAND ||
+				((unit->readyItem == -1) &&
+				 (Globals->USE_PREPARE_COMMAND == GameDefs::PREPARE_NORMAL)) ||
 				(pBat->itemNum==unit->readyItem) ||
 				(pBat->flags & BattleItemType::SHIELD)) {
 			if((pBat->flags & BattleItemType::SPECIAL) && special != -1) {
@@ -665,13 +669,17 @@
 		if (i<notbehind) {
 			int diff = s->maxhits - s->hits;
 			if (diff > 0) {
-				AString aName = AString(ItemDefs[s->race].name);
-				if (s->unit->type == U_WMON)
-					aName += AString(" in ");
-				else
-					aName += AString(" controlled by ");
-				aName += *s->unit->name;
+				AString aName = s->name;
 
+				if (s->damage != 0) {
+					b->AddLine(aName + " takes " + s->damage +
+							" hits bringing it to " + s->hits + "/" +
+							s->maxhits + ".");
+					s->damage = 0;
+				} else {
+					b->AddLine(aName + " takes no hits leaving it at " +
+							s->hits + "/" + s->maxhits + ".");
+				}
 				if (s->regen) {
 					int regen = s->regen;
 					if (regen > diff) regen = diff;
@@ -679,10 +687,6 @@
 					b->AddLine(aName + " regenerates " + regen +
 							" hits bringing it to " + s->hits + "/" +
 							s->maxhits + ".");
-				} else {
-					b->AddLine(aName + " takes " + diff +
-							" hits bringing it to " + s->hits + "/" +
-							s->maxhits + ".");
 				}
 			}
 		}
@@ -779,13 +783,15 @@
 void Army::Win(Battle * b,ItemList * spoils)
 {
 	int wintype;
-	if (count - NumAlive()) wintype = WIN_DEAD;
-	else wintype = WIN_NO_DEAD;
 
 	DoHeal(b);
-
 	WriteLosses(b);
+
 	int na = NumAlive();
+
+	if (count - na) wintype = WIN_DEAD;
+	else wintype = WIN_NO_DEAD;
+
 	AList units;
 
 	forlist(spoils) {
@@ -1154,6 +1160,7 @@
 
 	if(Globals->ARMY_ROUT == GameDefs::ARMY_ROUT_HITS_INDIVIDUAL)
 		hitsalive--;
+	temp->damage++;
 	temp->hits--;
 	if(temp->hits > 0) return;
 	temp->unit->losses++;
Index: army.h
===================================================================
RCS file: /home/cvs/atlantis/army.h,v
retrieving revision 1.13
retrieving revision 1.13.2.1
diff -u -r1.13 -r1.13.2.1
--- army.h	11 May 2002 17:00:48 -0000	1.13
+++ army.h	19 Oct 2002 04:03:42 -0000	1.13.2.1
@@ -86,6 +86,7 @@
 		int armor;
 		int hits;
 		int maxhits;
+		int damage;
 
 		BITFIELD battleItems;
 		int amuletofi;
Index: astring.cpp
===================================================================
RCS file: /home/cvs/atlantis/astring.cpp,v
retrieving revision 1.6
retrieving revision 1.6.2.1
diff -u -r1.6 -r1.6.2.1
--- astring.cpp	1 May 2002 19:30:15 -0000	1.6
+++ astring.cpp	20 Nov 2002 21:53:37 -0000	1.6.2.1
@@ -327,6 +327,8 @@
 	int ret = 0;
 	while ((str[place] >= '0') && (str[place] <= '9')) {
 		ret *= 10;
+		// Fix integer overflow to negative.
+		if (ret < 0) return 0;
 		ret += (str[place++] - '0');
 	}
 	return ret;
Index: astring.h
===================================================================
RCS file: /home/cvs/atlantis/astring.h,v
retrieving revision 1.7
diff -u -r1.7 astring.h
--- astring.h	21 Dec 2001 16:06:27 -0000	1.7
+++ astring.h	29 Jan 2003 06:20:57 -0000
@@ -25,7 +25,9 @@
 #ifndef ASTRING_CLASS
 #define ASTRING_CLASS
 
-#include <iostream.h>
+#include <iostream>
+using namespace std;
+
 #include "alist.h"
 
 class AString : public AListElem {
Index: battle.cpp
===================================================================
RCS file: /home/cvs/atlantis/battle.cpp,v
retrieving revision 1.24
diff -u -r1.24 battle.cpp
--- battle.cpp	15 Jun 2002 05:04:48 -0000	1.24
+++ battle.cpp	13 Jan 2003 00:50:02 -0000
@@ -231,6 +231,7 @@
                   ARegionList *pRegs )
 {
     Army * armies[2];
+    AString temp;
     assassination = ASS_NONE;
     attacker = att->faction;
 
@@ -263,7 +264,6 @@
         ItemList *spoils = new ItemList;
         armies[0]->Lose(this, spoils);
         GetSpoils(atts, spoils, ass);
-        AString temp;
         if (spoils->Num()) {
             temp = AString("Spoils: ") + spoils->Report(2,0,1) + ".";
         } else {
@@ -298,7 +298,6 @@
         ItemList *spoils = new ItemList;
         armies[1]->Lose(this, spoils);
         GetSpoils(defs, spoils, ass);
-        AString temp;
         if (spoils->Num()) {
             temp = AString("Spoils: ") + spoils->Report(2,0,1) + ".";
         } else {
@@ -319,6 +318,9 @@
     AddLine("Total Casualties:");
     armies[0]->Tie(this);
     armies[1]->Tie(this);
+    temp = "Spoils: none.";
+    AddLine("");
+    AddLine(temp);
     AddLine("");
     delete armies[0];
     delete armies[1];
@@ -515,7 +517,7 @@
 			forlist(&r2->objects) {
 				Object * o = (Object *) elem;
 				/* Set building capacity */
-				if (o->incomplete > 1 && o->IsBuilding()) {
+				if (o->incomplete < 1 && o->IsBuilding()) {
 					o->capacity = ObjectDefs[o->type].protect;
 				}
 			}
Index: fileio.cpp
===================================================================
RCS file: /home/cvs/atlantis/fileio.cpp,v
retrieving revision 1.13
diff -u -r1.13 fileio.cpp
--- fileio.cpp	28 Nov 2001 19:08:40 -0000	1.13
+++ fileio.cpp	29 Jan 2003 06:22:36 -0000
@@ -25,14 +25,8 @@
 #include "fileio.h"
 #include "gameio.h"
 
-#ifndef __BORLANDC__
-#include <iostream.h>
-#include <fstream.h>
-#else
 #include <fstream>
 #include <iostream>
-using namespace std;
-#endif
 
 #define F_ENDLINE '\n'
 
Index: fileio.h
===================================================================
RCS file: /home/cvs/atlantis/fileio.h,v
retrieving revision 1.6
diff -u -r1.6 fileio.h
--- fileio.h	4 Nov 2001 20:21:03 -0000	1.6
+++ fileio.h	29 Jan 2003 06:20:50 -0000
@@ -27,16 +27,9 @@
 
 #include "astring.h"
 
-#ifndef __BORLANDC__
-#include <iostream.h>
-#include <fstream.h>
-class ifstream;
-class ofstream;
-#else
 #include <fstream>
 #include <iostream>
 using namespace std;
-#endif
 
 class Ainfile {
 	public:
Index: game.cpp
===================================================================
RCS file: /home/cvs/atlantis/game.cpp,v
retrieving revision 1.52
retrieving revision 1.52.2.2
diff -u -r1.52 -r1.52.2.2
--- game.cpp	6 Jul 2002 02:51:38 -0000	1.52
+++ game.cpp	20 Nov 2002 21:53:37 -0000	1.52.2.2
@@ -69,13 +69,15 @@
 			Object * o = (Object *) elem;
 			forlist(&o->units) {
 				Unit * u = (Unit *) elem;
-				if (!(u->monthorders) && !u->faction->IsNPC()) {
-					if(u->GetFlag(FLAG_AUTOTAX) &&
-					   Globals->TAX_PILLAGE_MONTH_LONG && u->Taxers()) {
-						u->taxing = TAX_AUTO;
-					} else {
-						ProcessWorkOrder(u, 0);
-					}
+				if (u->monthorders || u->faction->IsNPC() ||
+						(Globals->TAX_PILLAGE_MONTH_LONG &&
+						 u->taxing != TAX_NONE))
+					continue;
+				if(u->GetFlag(FLAG_AUTOTAX) &&
+						(Globals->TAX_PILLAGE_MONTH_LONG && u->Taxers())) {
+					u->taxing = TAX_AUTO;
+				} else {
+					if(Globals->DEFAULT_WORK_ORDER) ProcessWorkOrder(u, 0);
 				}
 			}
 		}
@@ -1488,8 +1490,7 @@
                 ParseOrders( fac->num, &file, 0 );
                 file.Close();
             }
-			if(Globals->DEFAULT_WORK_ORDER)
-				DefaultWorkOrder();
+			DefaultWorkOrder();
         }
     }
 }
@@ -1721,7 +1722,7 @@
     unitseq++;
 	if(unitseq >= maxppunits) {
 		Unit **temp = new Unit*[maxppunits+10000];
-		memcpy(temp, ppUnits, maxppunits);
+		memcpy(temp, ppUnits, maxppunits*sizeof(Unit *));
 		maxppunits += 10000;
 		delete ppUnits;
 		ppUnits = temp;
Index: gamedefs.h
===================================================================
RCS file: /home/cvs/atlantis/gamedefs.h,v
retrieving revision 1.43
retrieving revision 1.43.2.1
diff -u -r1.43 -r1.43.2.1
--- gamedefs.h	11 Jul 2002 17:11:52 -0000	1.43
+++ gamedefs.h	17 Dec 2002 22:52:19 -0000	1.43.2.1
@@ -414,6 +414,13 @@
 	int MARKETS_SHOW_ADVANCED_ITEMS;
 
 	// Do we require the 'ready' command to set up battle items
+	// If prepare is strict, then the READY command MUST be used
+	// and there will be no automatic selection of battle items.
+	enum {
+		PREPARE_NONE = 0,
+		PREPARE_NORMAL = 1,
+		PREPARE_STRICT = 2,
+	};
 	int USE_PREPARE_COMMAND;
 
 	// Monsters have the option of advancing occasionally instead of just
Index: gameio.cpp
===================================================================
RCS file: /home/cvs/atlantis/gameio.cpp,v
retrieving revision 1.2
diff -u -r1.2 gameio.cpp
--- gameio.cpp	5 Jul 2001 00:18:01 -0000	1.2
+++ gameio.cpp	29 Jan 2003 06:22:58 -0000
@@ -26,10 +26,12 @@
 #include "gamedefs.h"
 #include <stdlib.h>
 #include <stdio.h>
-#include <iostream.h>
-#include <fstream.h>
 #include <time.h>
 
+#include <iostream>
+#include <fstream>
+using namespace std;
+
 extern "C" {
 #include "i_rand.h"
 }
@@ -59,10 +61,18 @@
 
 int getrandom(int range)
 {
+	int neg = (range < 0) ? 1 : 0;
+	int ret = 0;
+
     if (!range) return 0;
+	if (neg) range = -range;
+
     unsigned long i = isaac_rand( &isaac_ctx );
     i = i % range;
-    return (int) i;
+
+	if (neg) ret = (int)(i * -1);
+	else ret = (int)i;
+    return ret;
 }
 
 void seedrandom(int num)
Index: genrules.cpp
===================================================================
RCS file: /home/cvs/atlantis/genrules.cpp,v
retrieving revision 1.46
retrieving revision 1.46.2.4
diff -u -r1.46 -r1.46.2.4
--- genrules.cpp	17 Jul 2002 19:22:26 -0000	1.46
+++ genrules.cpp	18 Jan 2003 19:42:26 -0000	1.46.2.4
@@ -77,7 +77,7 @@
 	}
 
 	f.PutStr("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 "
-			"Transitional//EN\">");
+			"Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">");
 	f.Enclose(1, "HTML");
 	f.Enclose(1, "HEAD");
 	f.PutStr("<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; "
@@ -235,13 +235,13 @@
 	if(Globals->WANDERING_MONSTERS_EXIST) {
 		f.TagText("LI", f.Link("#nonplayers_monsters", "Wandering Monsters"));
 	}
-	f.TagText("LI", f.Link("#noplayers_controlled", "Controlled Monsters"));
+	f.TagText("LI", f.Link("#nonplayers_controlled", "Controlled Monsters"));
 	f.Enclose(0, "UL");
 	f.Enclose(0, "LI");
 	f.Enclose(1, "LI");
 	f.PutStr(f.Link("#orders", "Orders"));
 	f.Enclose(1, "UL");
-	f.TagText("LI", f.Link("#orders_appreviations", "Abbreviations"));
+	f.TagText("LI", f.Link("#orders_abbreviations", "Abbreviations"));
 	f.Enclose(0, "UL");
 	f.Enclose(0, "LI");
 	f.Enclose(1, "LI");
@@ -562,9 +562,7 @@
 		}
 	}
 	temp = "When a faction starts the game, it is given a one-man unit and ";
-	temp += (Globals->START_MONEY -
-			(Globals->LEADERS_EXIST ?
-			 Globals->LEADER_COST : Globals->MAINTENANCE_COST));
+	temp += Globals->START_MONEY;
 	temp += " silver in unclaimed money.  Unclaimed money is cash that your "
 		"whole faction has access to, but cannot be taken away in battle ("
 		"silver in a unit's possessions can be taken in battle).  This allows "
@@ -1698,8 +1696,9 @@
 		temp += "or food ";
 	temp += "to your units for maintenance, as a last resort.";
 	f.Paragraph(temp);
+	temp = "";
 	if(Globals->MULTIPLIER_USE == GameDefs::MULT_NONE) {
-		temp = AString("This fee is generally ") + Globals->MAINTENANCE_COST +
+		temp += AString("This fee is generally ") + Globals->MAINTENANCE_COST +
 			" silver for a normal character";
 		if (Globals->LEADERS_EXIST) {
 			temp += AString(", and ") + Globals->LEADER_COST +
@@ -1715,8 +1714,11 @@
 			temp += "All units ";
 		}
 		temp += "pay a fee based on the number of skill levels the character "
-			"has.  This fee is $";
-		temp += Globals->MAINTENANCE_MULTIPLIER + " per skill level";
+			"has.  This fee is the maximum of $";
+		temp += AString(Globals->MAINTENANCE_MULTIPLIER) + " per skill level";
+		temp += " and a cost of $";
+		temp += AString(Globals->MAINTENANCE_COST) + " for normal characters";
+		temp += AString(" or $") + Globals->LEADER_COST + " for leaders";
 		if(Globals->MULTIPLIER_USE != GameDefs::MULT_ALL) {
 			temp += ". All other characters pay a fee of ";
 			temp += Globals->MAINTENANCE_COST;
@@ -2115,10 +2117,10 @@
 			"no other practical uses.  However, the profit margins on "
 			"these items are usually quite high. ";
 		if(Globals->FACTION_LIMIT_TYPE == GameDefs::FACLIM_FACTION_TYPES) {
-			temp += "Buying and selling of these items in a region counts "
-				"against a Trade faction's quota of regions in which it "
-				"may undertake trade activity (note that buying and selling "
-				"normal items does not).";
+			temp += "Buying of trade items in a region counts against a "
+				"Trade faction's quota of regions in which it may "
+				"undertake trade activity (note that buying and selling "
+				"normal items does not, nor does selling of Trade items).";
 		}
 		f.Paragraph(temp);
 	}
@@ -4635,14 +4637,22 @@
 		f.ClassTagText("DIV", "rule", "");
 		f.LinkRef("prepare");
 		f.TagText("H4", "PREPARE [item]");
-		temp = "This command allows a mage or apprentice to prepare a "
-			"battle item (e.g. a Staff of Fire) for use in battle.  This "
-			"allows the mage to override the usual selection of battle "
-			"items, and also cancesl any spells set via the ";
+        temp = "This command allows a mage or apprentice to prepare a "
+			"battle item (e.g. a Staff of Fire) for use in battle. ";
+		if (Globals->USE_PREPARE_COMMAND == GameDefs::PREPARE_STRICT) {
+			temp += " This selects the battle item which will be used, ";
+		} else {
+			temp += "This allows the mage to override the usual selection "
+				"of battle items, ";
+		}
+		temp += "and also cancels any spells set via the ";
 		temp += f.Link("#combat", "COMBAT") + " order.";
 		f.Paragraph(temp);
 		f.Paragraph("Example:");
-		temp = "Use a staff of fire in preference to any other battle item.";
+		temp = "Select a staff of fire as the ";
+		if (!(Globals->USE_PREPARE_COMMAND == GameDefs::PREPARE_STRICT))
+			temp += "preferred ";
+		temp += "battle item.";
 		temp2 = "PREPARE STAF";
 		f.CommandExample(temp, temp2);
 	}
Index: market.cpp
===================================================================
RCS file: /home/cvs/atlantis/market.cpp,v
retrieving revision 1.3
diff -u -r1.3 market.cpp
--- market.cpp	5 Jul 2001 00:18:01 -0000	1.3
+++ market.cpp	21 Jan 2003 01:38:26 -0000
@@ -93,7 +93,8 @@
 
     if (population <= minpop)
     {
-        amount = minamt;
+    	if(ItemDefs[item].type & IT_FOOD) amount =  minamt;
+    	else amount = 0;
     } 
     else
     {
@@ -106,6 +107,11 @@
             amount = minamt +
                 ((maxamt - minamt) * (population - minpop)) /
                 (maxpop - minpop);
+            // Check minimum amount if item is economically relevant
+            if(((ItemDefs[item].type & IT_TRADE) && (type == M_BUY))
+            	|| (!(ItemDefs[item].type & IT_TRADE) && (type == M_SELL))) {
+            	if(amount < maxamt/6) amount = (maxamt/6);
+            }
         }
     }
 }
Index: monthorders.cpp
===================================================================
RCS file: /home/cvs/atlantis/monthorders.cpp,v
retrieving revision 1.39
diff -u -r1.39 monthorders.cpp
--- monthorders.cpp	11 Jul 2002 17:11:52 -0000	1.39
+++ monthorders.cpp	18 Jan 2003 20:18:50 -0000
@@ -522,12 +522,13 @@
 void Game::RunBuildHelpers(ARegion *r)
 {
 	forlist((&r->objects)) {
-		Object * obj = (Object *) elem;
+		Object *obj = (Object *) elem;
 		forlist ((&obj->units)) {
-			Unit * u = (Unit *) elem;
+			Unit *u = (Unit *) elem;
 			if (u->monthorders) {
 				if (u->monthorders->type == O_BUILD) {
 					BuildOrder *o = (BuildOrder *)u->monthorders;
+					Object *tarobj = NULL;
 					if(o->target) {
 						Unit *target = r->GetUnitId(o->target,u->faction->num);
 						if(!target) {
@@ -553,8 +554,12 @@
 							u->monthorders = 0;
 							continue;
 						}
-						if(u->object != target->object)
-							u->MoveUnit(target->object);
+						tarobj = target->build;
+						if (tarobj == NULL) tarobj = target->object;
+						if(u->object != tarobj)
+							u->MoveUnit(tarobj);
+					} else if (u->build != NULL && u->build != u->object) {
+						u->MoveUnit(u->build);
 					}
 				}
 			}
Index: parseorders.cpp
===================================================================
RCS file: /home/cvs/atlantis/parseorders.cpp,v
retrieving revision 1.44
diff -u -r1.44 parseorders.cpp
--- parseorders.cpp	29 Jun 2002 01:38:44 -0000	1.44
+++ parseorders.cpp	27 Jan 2003 02:26:28 -0000
@@ -1099,6 +1099,7 @@
 
 	if(!pCheck) {
 		int m = CountMages(u->faction);
+		int a = CountApprentices(u->faction);
 
 		for(i = 0; i < NFACTYPES; i++) {
 			u->faction->type[i] = factype[i];
@@ -1114,6 +1115,16 @@
 
 			return;
 		}
+		if(a > AllowedApprentices(u->faction)) {
+			u->Error(AString("FACTION: Too many apprentices to change "
+						"to that faction type."));
+
+			for(i = 0; i < NFACTYPES; i++) {
+				u->faction->type[ i ] = oldfactype[ i ];
+			}
+
+			return;
+		}
 
 		u->faction->lastchange = TurnNumber();
 		u->faction->DefaultOrders();
@@ -1467,6 +1478,7 @@
 			obj->type = ot;
 			obj->incomplete = ObjectDefs[obj->type].cost;
 			unit->MoveUnit(obj);
+			unit->build = obj;
 			unit->object->region->objects.Add(obj);
 		}
 	}
@@ -1846,6 +1858,8 @@
 	int turnDepth = 1;
 	int turnLast = 1;
 	int formDepth = 0;
+	int atsign;
+
 	TurnOrder *tOrder = new TurnOrder;
 	tOrder->repeating = repeat;
 
@@ -1860,6 +1874,7 @@
 		}
 		AString	saveorder = *order;
 		token = order->gettoken();
+		atsign = order->getat();
 
 		if (token) {
 			int i = Parse1Order(token);
@@ -1888,7 +1903,8 @@
 							ParseError(pCheck, unit, 0, "END: without FORM.");
 							break;
 						} else {
-							ParseError(pCheck, unit, 0, "TURN: without ENDTURN.");
+							ParseError(pCheck, unit, 0,
+									"TURN: without ENDTURN.");
 							if (!--turnDepth) {
 								unit->turnorders.Add(tOrder);
 								return new AString(saveorder);
@@ -1915,7 +1931,7 @@
 					if (!turnLast) {
 						ParseError(pCheck, unit, 0, "ENDTURN: without TURN.");
 					} else {
-						if (--turnDepth) 
+						if (--turnDepth)
 							tOrder->turnOrders.Add(new AString(saveorder));
 						turnLast = 0;
 					}
@@ -2261,7 +2277,7 @@
 					break;
 			}
 			if(Globals->CITY_RENAME_COST) {
-				cost = towntype+1* Globals->CITY_RENAME_COST;
+				cost = (towntype+1)* Globals->CITY_RENAME_COST;
 			}
 			int ok = 0;
 			switch(towntype) {
Index: runorders.cpp
===================================================================
RCS file: /home/cvs/atlantis/runorders.cpp,v
retrieving revision 1.39
retrieving revision 1.39.2.3
diff -u -r1.39 -r1.39.2.3
--- runorders.cpp	10 Jul 2002 15:32:30 -0000	1.39
+++ runorders.cpp	19 Oct 2002 04:03:42 -0000	1.39.2.3
@@ -825,7 +825,7 @@
 	/* First, count up pillagers */
 	int pillagers = CountPillagers(reg);
 
-	if (pillagers * 2 < reg->money / Globals->TAX_INCOME) {
+	if (pillagers * 2 * Globals->TAX_INCOME < reg->money) {
 		ClearPillagers(reg);
 		return;
 	}
@@ -956,24 +956,24 @@
 void Game::Do1EvictOrder(Object *obj, Unit *u)
 {
 	EvictOrder *ord = u->evictorders;
+	Object *to = obj->region->GetDummy();
 
 	while (ord && ord->targets.Num()) {
 		UnitId *id = (UnitId *)ord->targets.First();
 		ord->targets.Remove(id);
 		Unit *tar = obj->GetUnitId(id, u->faction->num);
 		delete id;
+		if (!tar) continue;
+
 		if(obj->IsBoat() &&
-			(TerrainDefs[obj->region->type].similar_type == R_OCEAN) &&
-			(!tar->CanReallySwim() || tar->GetFlag(FLAG_NOCROSS_WATER))) {
+				(TerrainDefs[obj->region->type].similar_type == R_OCEAN) &&
+				(!tar->CanReallySwim() || tar->GetFlag(FLAG_NOCROSS_WATER))) {
 			u->Error("EVICT: Cannot forcibly evict units over ocean.");
 			continue;
 		}
-		Object *to = obj->region->GetDummy();
 		tar->MoveUnit(to);
-		tar->Event(AString("Evicted from ") + *obj->name + " by " +
-				*u->name);
-		u->Event(AString("Evicted ") + *tar->name + " from " +
-				*obj->name);
+		tar->Event(AString("Evicted from ") + *obj->name + " by " + *u->name);
+		u->Event(AString("Evicted ") + *tar->name + " from " + *obj->name);
 	}
 }
 
@@ -2007,7 +2007,7 @@
 				Object * obj = (Object *) elem;
 				forlist((&obj->units)) {
 					Unit * u = (Unit *) elem;
-					if (u->needed || u->hunger)
+					if (u->needed > 0 || u->hunger > 0)
 						u->Short(u->needed, u->hunger);
 				}
 			}
Index: spells.cpp
===================================================================
RCS file: /home/cvs/atlantis/spells.cpp,v
retrieving revision 1.21
diff -u -r1.21 spells.cpp
--- spells.cpp	1 Jul 2002 13:01:53 -0000	1.21
+++ spells.cpp	20 Jan 2003 06:36:18 -0000
@@ -399,7 +399,7 @@
 				if(token) {
 					z = token->value();
 					delete token;
-					if(z < 0 || (z > Globals->UNDERWORLD_LEVELS +
+					if(z < 0 || (z >= Globals->UNDERWORLD_LEVELS +
 								Globals->UNDERDEEP_LEVELS +
 								Globals->ABYSS_LEVEL + 2)) {
 						u->Error("CAST: Invalid Z coordinate specified.");
@@ -605,7 +605,7 @@
 			RunEnchantSwords(r,u);
 			break;
 		case S_CONSTRUCT_GATE:
-			RunConstructGate(r,u);
+			RunConstructGate(r,u,sk);
 			break;
 		case S_ENGRAVE_RUNES_OF_WARDING:
 			RunEngraveRunes(r,o,u);
@@ -946,7 +946,7 @@
 	r->NotifySpell(u,S_EARTH_LORE, &regions );
 }
 
-void Game::RunConstructGate(ARegion *r,Unit *u)
+void Game::RunConstructGate(ARegion *r,Unit *u, int spell)
 {
 	if (TerrainDefs[r->type].similar_type == R_OCEAN) {
 		u->Error("Gates may not be constructed at sea.");
@@ -962,10 +962,17 @@
 		u->Error("Can't afford to construct a Gate.");
 		return;
 	}
+	u->SetMoney(u->GetMoney() - 1000);
+
+	int level = u->GetSkill(spell);
+	int chance = level * 20;
+	if (getrandom(100) >= chance) {
+		u->Event("Attempts to construct a gate, but fails.");
+		return;
+	}
 
 	u->Event(AString("Constructs a Gate in ")+r->ShortPrint( &regions )+".");
 	u->Practise(S_CONSTRUCT_GATE);
-	u->SetMoney(u->GetMoney() - 1000);
 	regions.numberofgates++;
 	r->gate = regions.numberofgates;
 	r->NotifySpell(u,S_ARTIFACT_LORE, &regions );
@@ -1349,8 +1356,8 @@
 {
 	int level = u->GetSkill(S_EARTH_LORE);
 
-	int amt = r->Wages() * level * 2;
 	if (level > r->earthlore) r->earthlore = level;
+	int amt = r->Wages() * level * 2;
 
 	u->items.SetNum(I_SILVER,u->items.GetNum(I_SILVER) + amt);
 	u->Event(AString("Casts Earth Lore, raising ") + amt + " silver.");
Index: spells.h
===================================================================
RCS file: /home/cvs/atlantis/spells.h,v
retrieving revision 1.6
diff -u -r1.6 spells.h
--- spells.h	1 Jul 2002 13:01:53 -0000	1.6
+++ spells.h	20 Jan 2003 06:36:31 -0000
@@ -79,7 +79,7 @@
 void RunSummonBalrog(ARegion *,Unit *);
 void RunCreateArtifact(ARegion *,Unit *,int,int);
 void RunEngraveRunes(ARegion *,Object *,Unit *);
-void RunConstructGate(ARegion *,Unit *);
+void RunConstructGate(ARegion *,Unit *,int);
 void RunEnchantSwords(ARegion *,Unit *);
 void RunEnchantArmor(ARegion *,Unit *);
 void RunMindReading(ARegion *,Unit *);
Index: template.cpp
===================================================================
RCS file: /home/cvs/atlantis/template.cpp,v
retrieving revision 1.11
retrieving revision 1.11.2.1
diff -u -r1.11 -r1.11.2.1
--- template.cpp	6 Jul 2002 02:51:38 -0000	1.11
+++ template.cpp	22 Jul 2002 20:45:44 -0000	1.11.2.1
@@ -74,7 +74,7 @@
 };
 
 
-static char *fill[] = {
+static char *terfill[] = {
  // block
  " #### ",
  " #### ",
@@ -566,11 +566,11 @@
                     if (len > FILL_SIZE) len = FILL_SIZE;
                     memcpy(dest + x, name, len);
                 } else {
-                    memcpy(dest + x, fill[t], FILL_SIZE);
+                    memcpy(dest + x, terfill[t], FILL_SIZE);
                 }
             } else {
                 t++;
-                memcpy(dest + x, fill[t], FILL_SIZE);
+                memcpy(dest + x, terfill[t], FILL_SIZE);
             }
         }
 
Index: unit.cpp
===================================================================
RCS file: /home/cvs/atlantis/unit.cpp,v
retrieving revision 1.53
diff -u -r1.53 unit.cpp
--- unit.cpp	16 Jul 2002 23:28:41 -0000	1.53
+++ unit.cpp	27 Jan 2003 02:28:56 -0000
@@ -587,6 +587,7 @@
 	canattack = 1;
 	nomove = 0;
 	enter = 0;
+	build = NULL;
 	leftShip = 0;
 	destroy = 0;
 	if (attackorders) delete attackorders;
@@ -646,6 +647,7 @@
 	} else if(type == U_GUARDMAGE) {
 		combat = S_FIRE;
 	} else{
+		/* Set up default orders for any faction unit which submits none */
 		if(obj->region->type != R_NEXUS) {
 			if(GetFlag(FLAG_AUTOTAX) &&
 					Globals->TAX_PILLAGE_MONTH_LONG && Taxers()) {
@@ -1023,16 +1025,29 @@
 
 int Unit::Practise(int sk)
 {
-	int days, bonus, men, curlev, reqsk, reqlev;
+	int days, bonus, men, curlev, reqsk, reqlev, max;
 	unsigned int i;
 
 	bonus = Globals->SKILL_PRACTISE_AMOUNT;
 	if (practised || (bonus < 1)) return 1;
 	days = skills.GetDays(sk);
 	men = GetMen();
-	if (men < 1 || days < 1 || days >= 450 * men) return 0;
 
+	// Fix the code checking for max level so that we actually compute it
+	// correctly for non-leader units :(
+	if (men < 1 || days < 1) return 0;
+
+	max = 1000;
+	forlist (&items) {
+		Item *i = (Item *)elem;
+		if (ItemDefs[i->type].type & IT_MAN) {
+			int m = SkillMax(sk, i->type);
+			if (m < max) max = m;
+		}
+	}
 	curlev = GetRealSkill(sk);
+	if (curlev >= max) return 0;
+
 	for(i = 0; i < sizeof(SkillDefs[sk].depends)/sizeof(SkillDepend); i++) {
 		reqsk = SkillDefs[sk].depends[i].skill;
 		if (reqsk == -1) break;
@@ -1137,7 +1152,7 @@
 int Unit::MaintCost()
 {
 	int retval = 0;
-	int levels = 0;
+	int i;
 	if (type == U_WMON || type == U_GUARD || type == U_GUARDMAGE) return 0;
 
 	int leaders = GetMen(I_LEADERS);
@@ -1145,44 +1160,34 @@
 	int nonleaders = GetMen() - leaders;
 	if (nonleaders < 0) nonleaders = 0;
 
-	switch(Globals->MULTIPLIER_USE) {
-		case GameDefs::MULT_NONE:
-			retval += Globals->MAINTENANCE_COST * nonleaders;
-			retval += Globals->LEADER_COST * leaders;
-			break;
-		case GameDefs::MULT_MAGES:
-			if(type == U_MAGE) {
-				retval += SkillLevels() * Globals->MAINTENANCE_MULTIPLIER;
-			} else {
-				retval += Globals->MAINTENANCE_COST * nonleaders;
-				retval += Globals->LEADER_COST * leaders;
-			}
-			break;
-		case GameDefs::MULT_LEADERS:
-			levels = SkillLevels();
-			if(levels)
-				retval += levels * Globals->MAINTENANCE_MULTIPLIER * leaders;
-			else
-				retval += Globals->LEADER_COST * leaders;
-			retval += Globals->MAINTENANCE_COST * nonleaders;
-			break;
-		case GameDefs::MULT_ALL:
-			levels = SkillLevels();
-			if(levels) {
-				retval += levels*Globals->MAINTENANCE_MULTIPLIER*leaders;
-				retval += levels*Globals->MAINTENANCE_MULTIPLIER*nonleaders;
-			} else {
-				retval += Globals->LEADER_COST * leaders;
-				retval += Globals->MAINTENANCE_COST * nonleaders;
-			}
-	}
+	// Handle leaders
+	// Leaders are counted at maintenance_multiplier * skills in all except
+	// the case where it's not being used (mages, leaders, all)
+	if (Globals->MULTIPLIER_USE != GameDefs::MULT_NONE) {
+		i = leaders * SkillLevels() * Globals->MAINTENANCE_MULTIPLIER;
+		if (i < (leaders * Globals->LEADER_COST))
+			i = leaders * Globals->LEADER_COST;
+	} else
+		i = leaders * Globals->LEADER_COST;
+	retval += i;
+
+	// Handle non-leaders
+	// Non leaders are counted at maintenance_multiplier * skills only if
+	// all characters pay that way.
+	if (Globals->MULTIPLIER_USE == GameDefs::MULT_ALL) {
+		i = nonleaders * SkillLevels() * Globals->MAINTENANCE_MULTIPLIER;
+		if (i < (nonleaders * Globals->MAINTENANCE_COST))
+			i = nonleaders * Globals->MAINTENANCE_COST;
+	} else
+		i = nonleaders * Globals->MAINTENANCE_COST;
+	retval += i;
 
 	return retval;
 }
 
 void Unit::Short(int needed, int hunger)
 {
-	int n = 0;
+	int n = 0, i, levels;
 
 	if (faction->IsNPC())
 		return; // Don't starve monsters and the city guard!
@@ -1217,7 +1222,15 @@
 				SetMen(i,GetMen(i) - 1);
 				n++;
 			}
-			needed -= Globals->MAINTENANCE_COST;
+			if (Globals->MULTIPLIER_USE == GameDefs::MULT_ALL) {
+				levels = SkillLevels();
+				i = levels * Globals->MAINTENANCE_MULTIPLIER;
+				if (i < Globals->MAINTENANCE_COST)
+					i = Globals->MAINTENANCE_COST;
+				needed -= i;
+			} else
+				needed -= Globals->MAINTENANCE_COST;
+
 			hunger -= Globals->UPKEEP_MINIMUM_FOOD;
 			if (needed < 1 && hunger < 1) {
 				if (n) Error(AString(n) + " starve to death.");
@@ -1231,7 +1244,15 @@
 			SetMen(I_LEADERS,GetMen(I_LEADERS) - 1);
 			n++;
 		}
-		needed -= Globals->LEADER_COST;
+		if (Globals->MULTIPLIER_USE != GameDefs::MULT_NONE) {
+			levels = SkillLevels();
+			i = levels * Globals->MAINTENANCE_MULTIPLIER;
+			if (i < Globals->LEADER_COST)
+				i = Globals->LEADER_COST;
+			needed -= i;
+		} else
+			needed -= Globals->LEADER_COST;
+
 		hunger -= Globals->UPKEEP_MINIMUM_FOOD;
 		if (needed < 1 && hunger < 1) {
 			if (n) Error(AString(n) + " starve to death.");
@@ -1871,7 +1892,7 @@
 	int levels = 0;
 	forlist(&skills) {
 		Skill *s = (Skill *)elem;
-		levels += GetLevelByDays(s->days);
+		levels += GetLevelByDays(s->days/GetMen());
 	}
 	return levels;
 }
@@ -1904,7 +1925,7 @@
 		}
 	}
 	for(i = 0; i < NSKILLS; i++) {
-		if(SkillDefs[i].flags & SkillType::DISABLED) continue;
+		if (!can_forget[i]) continue;
 		Skill *si = GetSkillObject(i);
 		for(int j=0; j < NSKILLS; j++) {
 			if(SkillDefs[j].flags & SkillType::DISABLED) continue;
Index: unit.h
===================================================================
RCS file: /home/cvs/atlantis/unit.h,v
retrieving revision 1.24
diff -u -r1.24 unit.h
--- unit.h	11 Jul 2002 16:03:53 -0000	1.24
+++ unit.h	18 Jan 2003 20:18:50 -0000
@@ -254,6 +254,7 @@
 		/* Orders */
 		int destroy;
 		int enter;
+		Object *build;
 		int leftShip;
 		UnitId *promote;
 		AList findorders;
Index: ceran/rules.cpp
===================================================================
RCS file: /home/cvs/atlantis/ceran/rules.cpp,v
retrieving revision 1.30
retrieving revision 1.30.2.1
diff -u -r1.30 -r1.30.2.1
--- ceran/rules.cpp	11 Jul 2002 17:11:55 -0000	1.30
+++ ceran/rules.cpp	17 Dec 2002 22:52:21 -0000	1.30.2.1
@@ -165,7 +165,7 @@
 	0,	// LIMITED_MAGES_PER_BUILDING
 	GameDefs::REPORT_NOTHING, // TRANSIT_REPORT
 	0,  // MARKETS_SHOW_ADVANCED_ITEMS
-	0,	// USE_PREPARE_COMMAND
+	GameDefs::PREPARE_NONE,	// USE_PREPARE_COMMAND
 	15,	// MONSTER_ADVANCE_MIN_PERCENT
 	0,	// MONSTER_ADVANCE_HOSTILE_PERCENT
 	0,	// HAVE_EMAIL_SPECIAL_COMMANDS
Index: conquest/rules.cpp
===================================================================
RCS file: /home/cvs/atlantis/conquest/rules.cpp,v
retrieving revision 1.39
retrieving revision 1.39.2.1
diff -u -r1.39 -r1.39.2.1
--- conquest/rules.cpp	11 Jul 2002 17:11:57 -0000	1.39
+++ conquest/rules.cpp	17 Dec 2002 22:52:23 -0000	1.39.2.1
@@ -164,7 +164,7 @@
 	0,	// LIMITED_MAGES_PER_BUILDING
 	GameDefs::REPORT_NOTHING, // TRANSIT_REPORT
 	0,  // MARKETS_SHOW_ADVANCED_ITEMS
-	0,	// USE_PREPARE_COMMAND
+	GameDefs::PREPARE_NONE,	// USE_PREPARE_COMMAND
 	15,	// MONSTER_ADVANCE_MIN_PERCENT
 	0,	// MONSTER_ADVANCE_HOSTILE_PERCENT
 	0,	// HAVE_EMAIL_SPECIAL_COMMANDS
Index: realms/rules.cpp
===================================================================
RCS file: /home/cvs/atlantis/realms/rules.cpp,v
retrieving revision 1.37
retrieving revision 1.37.2.1
diff -u -r1.37 -r1.37.2.1
--- realms/rules.cpp	11 Jul 2002 17:11:58 -0000	1.37
+++ realms/rules.cpp	17 Dec 2002 22:52:24 -0000	1.37.2.1
@@ -166,7 +166,7 @@
 	0,	// LIMITED_MAGES_PER_BUILDING
 	GameDefs::REPORT_NOTHING, // TRANSIT_REPORT
 	0,  // MARKETS_SHOW_ADVANCED_ITEMS
-	0,	// USE_PREPARE_COMMAND
+	GameDefs::PREPARE_NONE,	// USE_PREPARE_COMMAND
 	15,	// MONSTER_ADVANCE_MIN_PERCENT
 	0,	// MONSTER_ADVANCE_HOSTILE_PERCENT
 	1,	// HAVE_EMAIL_SPECIAL_COMMANDS
Index: standard/rules.cpp
===================================================================
RCS file: /home/cvs/atlantis/standard/rules.cpp,v
retrieving revision 1.42
retrieving revision 1.42.2.1
diff -u -r1.42 -r1.42.2.1
--- standard/rules.cpp	11 Jul 2002 17:12:00 -0000	1.42
+++ standard/rules.cpp	17 Dec 2002 22:52:25 -0000	1.42.2.1
@@ -166,7 +166,7 @@
 	0,	// LIMITED_MAGES_PER_BUILDING
 	GameDefs::REPORT_NOTHING, // TRANSIT_REPORT
 	0,  // MARKETS_SHOW_ADVANCED_ITEMS
-	0,	// USE_PREPARE_COMMAND
+	GameDefs::PREPARE_NONE,	// USE_PREPARE_COMMAND
 	15,	// MONSTER_ADVANCE_MIN_PERCENT
 	0,	// MONSTER_ADVANCE_HOSTILE_PERCENT
 	1,	// HAVE_EMAIL_SPECIAL_COMMANDS
Index: wyreth/rules.cpp
===================================================================
RCS file: /home/cvs/atlantis/wyreth/rules.cpp,v
retrieving revision 1.44
retrieving revision 1.44.2.1
diff -u -r1.44 -r1.44.2.1
--- wyreth/rules.cpp	11 Jul 2002 17:12:02 -0000	1.44
+++ wyreth/rules.cpp	17 Dec 2002 22:52:27 -0000	1.44.2.1
@@ -165,7 +165,7 @@
 	0,	// LIMITED_MAGES_PER_BUILDING
 	GameDefs::REPORT_NOTHING, // TRANSIT_REPORT
 	0,  // MARKETS_SHOW_ADVANCED_ITEMS
-	0,	// USE_PREPARE_COMMAND
+	GameDefs::PREPARE_NONE,	// USE_PREPARE_COMMAND
 	15,	// MONSTER_ADVANCE_MIN_PERCENT
 	0,	// MONSTER_ADVANCE_HOSTILE_PERCENT
 	1,	// HAVE_EMAIL_SPECIAL_COMMANDS
